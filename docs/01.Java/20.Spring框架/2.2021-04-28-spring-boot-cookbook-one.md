---
title: Spring Boot菜谱（一）——编写自动记录Controller层请求的注解
date: 2021-04-28 11:57:00
permalink: /pages/spring-boot-cookbook-one/
description: 详细介绍如何使用AOP和自定义注解实现Spring Boot Controller层请求日志的自动记录功能
categories: 
  - Java
  - Spring框架
tags: 
  - Spring Boot
  - AOP
  - 自定义注解
  - 日志记录
author: 
  name: 吉森
  link: https://github.com/lhing17
---

今天菜品：

编写一个自动记录Controller层请求记录的注解。
## 起因

俗话说，懒惰是程序员的第一生产力。为了偷懒不在每一个Controller层方法上都编写记录日志的代码，我想到了利用AOP（面向切面编程）的方式，通过一个自定义注解来自动实现记录日志的功能。

## 解决方案

我们将上述需求分解一下，形成需要解决的问题点，如下：

1. 编写注解，注解应该作用于方法上，并可以在运行时通过反射获取到
2. 编写注解处理器，注解处理器应该是一个切面类，并定义在任何由RequestLog注解标注的类进行切入
3. 通过反射获取到要注入的方法，再获取到方法的参数和返回值，利用日志将方法的参数和返回值按指定格式输出（或保存到数据库、redis等）

<!-- more -->

## 编写注解

将注解命名为RequestLog，示例代码如下：

```java
/**
 * 用于记录请求参数的日志
 *
 * @author G. Seinfeld
 * @since 2021/04/28
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequestLog {

    /**
     * 所属模块，不赋值将使用Controller的全名代替
     */
    String module() default "";
}
```

在编写注解时，使用 `@Target` 元注解规定当前注解所标注的对象，常见值包括：

- TYPE -> 类
- FIELD -> 属性
- METHOD -> 方法
- PARAMETER -> 方法的参数
- CONSTRUCTOR -> 构造器
- LOCAL_VARIABLE -> 局部变量
- ANNOTATION_TYPE -> 注解
- PACKAGE -> 包

使用 `@Retention` 元注解规定当前注解的生命周期，常见值包括：

- SOURCE -> 源代码级别
- CLASS -> class文件级别
- RUNTIME -> 虚拟机运行时级别

注解中定义了一个可配置项，即请求的Controller所属的模块。我们还可以根据实际需要增加其他配置项。

## 编写注解处理器

首先在 `pom.xml` 文件中引用 AOP 处理所需依赖包，由于是 Spring Boot 项目，这里直接使用 starter 的方式快捷引入：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
    <version>2.3.2.RELEASE</version>
</dependency>
```

然后创建切面类：

```java
/**
 * @author G. Seinfeld
 * @since 2021/04/28
 */
@Aspect
@Component
public class RequestLogHandler {

    @Pointcut("@annotation(cn.gsein.annotations.RequestLog)")
    public void logPointcut() {
    }
}
```

在 Spring AOP 中，我们使用 `@Aspect` 注解定义一个切面类，使用 `@Pointcut` 注解标注在一个空方法上，用于定义一个切入点。在本需求中，我们希望定义的切入点是被注解标注的方法，因此，我们将切入点的表达式声明为：

```java
@annotation(xxx.xxx.xxx.RequestLog)
```

更多的切入点表达式写法请自行查阅文档。

## 编写记录日志的逻辑

接下来我们在 `RequestLogHandler` 类中编写具体处理记录日志逻辑的方法，示例代码如下：

```java
@AfterReturning(value = "logPointcut()", returning = "result")
public void doAfterRequest(JoinPoint joinPoint, Object result) {

    try {
        // 切面所属对象
        final Object instance = joinPoint.getTarget();
        // 对象对应的class对象
        final Class<?> instanceClass = instance.getClass();
        // 根据class对象获取logger
        Logger logger = LoggerFactory.getLogger(instanceClass);

        // 获取方法名
        final MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        final Method method = signature.getMethod();
        final String methodName = method.getName();

        // 获取注解
        final RequestLog annotation = method.getAnnotation(RequestLog.class);
        // 获取模块名
        String moduleName = annotation.module();
        if (StringUtils.isEmpty(moduleName)) {
            moduleName = instanceClass.getSimpleName();
        }

        // 拼接请求参数
        final Object[] args = joinPoint.getArgs();
        StringBuilder sb = new StringBuilder();
        int i = 0;
        for (Object arg : args) {
            sb.append("arg").append(i++).append(":");
            sb.append(JSON.toJSONString(arg)).append(",");
        }
        if (sb.length() > 0) {
            sb.deleteCharAt(sb.length() - 1);
        }

        logger.info("请求{}模块的{}接口，请求参数为{}，返回结果为{}", moduleName, methodName, sb.toString(), JSON.toJSONString(result));
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
Spring AOP 给我们提供了几种切面增强的方式：

- `@Around`：环绕增强，即在切入方法前后都进行处理
- `@AfterReturning`：后置增强，即方法返回时处理
- `@Before`：前置增强，即进入方法前处理
- `@AfterThrowing`：异常抛出增强，即方法抛出异常时处理
- `@After`：不管是抛出异常或者正常退出都会执行

示例代码中我们使用了后置增强的方式，即在方法返回时进行处理，这样可以同时获得方法的参数和返回值，符合我们的需求。`@AfterReturning` 的 `value` 配置项配置的是切入点，这里直接使用上面方法定义的切入点。`returning` 配置项指的是将返回值绑定到哪个对象上，这里指定的是方法参数中的对象。

我们可以根据切入点的 `JoinPoint` 对象，通过反射获取到切入方法的 `method` 对象、所属 Controller 类的实例、方法参数等，再按照相应的规则对这些对象进行拼接和组合，并通过 logger 进行记录。

## 最后的说明

- 本文提供的只是 demo 级别的代码，重点在于介绍思路和相关知识。如需在生产中使用，请根据实际需求自行修改和完善
- 如果在方法发生异常时也需要记录日志，需要额外编写一个 `@AfterThrowing` 标注的处理方法
- 本文代码中的异常处理比较粗糙，请根据实际情况自行完善

