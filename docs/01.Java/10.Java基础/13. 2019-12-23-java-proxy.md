---
title: Java代理模式详解
date: 2019-12-23 19:44:43
tags: 
  - Java
  - 设计模式
categories: 
  - Java
permalink: /pages/java-proxy/
description: 深入解析Java中的代理模式，包括静态代理和动态代理（JDK动态代理、CGLIB动态代理）的实现原理和使用方法。
author: 
  name: 吉森
  link: https://github.com/lhing17
---

## 代理模式概述

代理模式是23种设计模式之一，属于结构型模式。代理模式是最常见也是最常用的模式之一，只不过有很多设计模式相关工作由Spring等框架代替我们完成，因此平时我们没有太多的直接接触。但是我们还是应该去学习这些设计模式，因为理解原理在很多情况下对调试各种问题有很大帮助。最近我对java的代理模式及其实现又进行了一次梳理，发现之前很多方面的理解有偏差，特此记录下来。

<!-- more -->

首先说代理模式。代理模式听起来像我们想做一件事情又懒得做，于是找一个人代为办理。但是在java里这么理解代理模式很危险，甚至有的时候会误导我们对问题的调试。在java中的代理模式实际上是对对象某个行为的控制或者增强，当然从某种意义上讲，增强也是一种控制。java中的代理模式我们可以理解为小孩子想要看电视，家长是小孩子的代理，决定是否让小孩子看电视。我们先去创建一个小孩子的类：

```java
class Child {
    public void watchTelevision() {
        System.out.println("看电视");
    }
}
```

再创建一个家长的类：

```java
class Parent {
    private Child child;

    public Parent(Child child) {
        this.child = child;
    }

    public void childWatchTelevision() {
        // 某种条件下允许小孩看电视，比如控制时间段
        if (XXX) {
            child.watchTelevision();
        }
    }
}
```
上述代码中，家长和小孩是一个组合的关系，家长可以控制小孩看电视这个行为。这段代码基本实现了代理模式的思想，但是和规范的代理模式还差了点东西，就是同源性。代理模式规定，代理对象和被代理的对象应该是同源的，也就是说实现相同的接口或者彼此间有继承关系。按照这一要求，我们对上述代码进行一定的改造。

```java
interface IChild {
    void watchTelevision();
}

class Child implements IChild {
    @Override
    public void watchTelevision() {
        System.out.println("看电视");
    }
}

class ChildProxy implements IChild {
    private Child child;

    public ChildProxy(Child child) {
        this.child = child;
    }

    @Override
    public void watchTelevision() {
        // 某种条件下允许小孩看电视，比如控制时间段
        if (XXX) {
            child.watchTelevision();
        }
    }
}
```

我们让代理类改名为ChildProxy，并让代理对象和被代理对象同时实现IChild接口，保证二者的同源性，这样一个最简单的代理模式就完成了。那么在小孩看电视的时候，我们调用代理对象的watchTelevision方法，就可以实现对小孩看电视这一行为的控制了。

```java
class Test {
    public static void main(String[] args) {
        IChild child = new ChildProxy(new Child());
        child.watchTelevision();
    }
}
```

## 静态代理

上述代理的方式称为静态代理。之所以叫静态代理，是因为我们必须显式地为每一个要代理的对象编写一个代理类。这样做的缺点在于工作量大，而且不够灵活。有的时候我们需要统一的控制多种对象的行为，这时我们就应该使用动态代理。

## 动态代理

动态代理是指我们归纳出某些对象实现代理的方式，通过一个控制器统一地为各个对象生成代理类。例如我们想控制小孩能不能看电视，还想控制家里的宠物猫能不能出去玩，而我们又不想为小孩和猫分别编写代理类，这时就需要动态代理的帮助。在java中有两种常用的动态代理实现方案，即jdk自带的动态代理和cglib动态代理。jdk动态代理是基于接口实现的代理，cglib代理则是通过asm字节码技术实现动态代理，可以基于接口也可以基于类。

### JDK动态代理

jdk动态代理基于接口实现，提供了一个InvocationHandler的接口，用于动态生成代理对象，用法如下：

```java
public class JdkDynamicProxy implements InvocationHandler {
    // 要代理的对象
    private Object origin;

    public JdkDynamicProxy(Object origin) {
        this.origin = origin;
    }

    public Object getInstance() {
        return Proxy.newProxyInstance(getClass().getClassLoader(), origin.getClass().getInterfaces(), this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("调用方法前");
        Object invoke = method.invoke(origin, args);
        System.out.println("调用方法后");
        return invoke;
    }

    public static void main(String[] args) {
        System.getProperties().put("jdk.proxy.ProxyGenerator.saveGeneratedFiles", "true");
        JdkDynamicProxy proxy = new JdkDynamicProxy(new Child());
        IChild child = (IChild) proxy.getInstance();
        child.watchTelevision();
    }
}
```

我们自定义一个类，实现InvocationHandler接口，关键点在于重写接口中的invoke方法，用于调用被代理对象的方法。我们把要代理的对象origin作为自定义类的一个属性，为了适配多个被代理对象，这里使用了Object类型。invoke方法中第一个对象proxy是实际的代理对象，第二个对象method是要调用的方法，第三个对象args是调用方法的参数，在invoke方法中可以通过method.invoke(origin, args)来调用被代理对象的相应方法。getInstance方法用于生成代理对象，内部是使用Proxy.newProxyInstance方法实现，该方法需要传三个参数，分别为ClassLoader对象、被代理对象的接口，以及InvocationHandler实例。该方法底层执行了本地方法，可以动态生成代理类的二进制码。通过在环境变量中将jdk.proxy.ProxyGenerator.saveGeneratedFiles设置为true，可以在项目根目录中实际生成代理类的class文件。

### CGLIB动态代理

与jdk动态代理类似，cglib动态代理提供了MethodInterceptor接口，用于动态生成代理对象，用法如下：

```java
public class CglibDynamicProxy implements MethodInterceptor {

    private Object origin;

    public CglibDynamicProxy(Object origin) {
        this.origin = origin;
    }

    public Object getInstance() {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(origin.getClass());
        enhancer.setCallback(this);
        return enhancer.create();
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("调用方法前");
        Object invoke = methodProxy.invokeSuper(o, objects);
        System.out.println("调用方法后");
        return invoke;
    }

    public static void main(String[] args) {
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/home/XXX");
        CglibDynamicProxy proxy = new CglibDynamicProxy(new Child());
        Child child = (Child) proxy.getInstance();
        child.watchTelevision();
    }
}
```

我们自定义一个类，实现MethodInterceptor接口，重写接口中的intercept方法，此方法与InvocationHandler中的invoke方法相似，但是比invoke方法多传递了一个参数，方法中第一个对象o还是实际的代理对象，第二个对象method是要调用的方法，第三个对象objects是调用方法的参数，新增的methodProxy对象是代理对象中的方法，通过调用invokeSuper方法，可以实现通过代理对象调用被代理对象的方法。因此，既可以通过method.invoke(origin, objects)来调用被代理对象的相应方法，也可以通过methodProxy.invokeSuper(o, objects)来达到相同的目的。getInstance方法同样用于生成代理对象，内部是使用Enhancer的create方法创建代理对象。通过在环境变量中设置DebuggingClassWriter.DEBUG_LOCATION_PROPERTY值（生成Class文件所在的根路径），可以在项目根目录中实际生成代理类的class文件。

## 总结

代理模式用于对被代理对象的方法进行控制或者加强。为了保证灵活性和可扩展性，通常使用动态代理来实现代理模式。在java中可以通过jdk动态代理和cglib动态代理两种方式来实现动态代理。二者的区别在于jdk是基于接口的，cglib是动态修改字节码，可以基于接口也可以基于类。

## 踩坑点

- 代理对象和被代理对象应该是组合关系，而不是继承关系。
- 代理模式下，方法仍是由原对象执行，只不过代理对象对方法执行进行了控制。