---
title: Java中equals()与==的区别详解
date: 2019-02-27 20:39:05
permalink: /pages/01b32f/
categories:
  - Java
  - Java基础
tags:
  - Java基础
  - equals
  - 比较运算符
author: 
  name: 吉森
  link: https://github.com/lhing17
description: 深入分析Java中equals()方法与==运算符的区别，包括基本类型、引用类型、字符串、包装类等不同场景下的比较行为。
---

# Java中equals()与==的区别详解

看到这个标题，是不是觉得刚学java三天的同学都会回答？的确，这道题的定位是送分题，但是事情似乎并没有这么简单。最近去某培训机构招聘的时候，把这道题出给刚培训出来的同学们，结果20个人里只有两个人比较准确地回答出了这个问题。在听到这个问题时，大部分培训班学生的答案是"双等号用于比较地址，equals用于比较内容"。如果满分是10分的话，这个回答我觉得只能给3分。下面我们就比较严谨地来讨论一下这道送分题。

<!-- more -->

## 为什么要比较这两者？

首先，为什么把二者放在一起比较？因为二者的作用看起来是一致的，都是用于比较两个变量（或字面量）是否一致。既然二者同时在java语法中存在，就说明二者的效果实际上是不一致的。

## 基本区别

第一个区别在于双等号是二元比较运算符，equals是一个方法。有人说，这不是废话么？此言差矣。确定它们的定位才能明确它们的使用范围。作为运算符，双等号可以用于连接两个基本类型的变量（或字面量），也可以连接两个对象。相比之下，equals只能用来连接两个对象，一个作为调用方，一个作为参数。

第二个区别在于比较方式不同。

### 双等号（==）

对于基本类型数据，双等号用于比较二者的值是否相等，如：

```java
int a = 1;
int b = 2;
System.out.println(a == b); // false
```

对于引用类型的变量，双等号用于比较二者是否指向一个对象，如Student有两个字段name和age：

```java
Student john = new Student("John", 25);
Student mary = new Student("Mary", 25);
System.out.println(john == mary); // false
```

### equals方法

equals方法不能用于比较基本类型数据。

equals方法是java.lang.Object类中的方法，由于Object类是java中的老祖宗，所有的类都默认继承自Object类，也就默认有了equals方法。那么Object类中的equals方法是怎么实现的呢？通过查阅源码，我们发现，Object类中的实现方式就是使用双等号。即在不重写equals方法的情况下，equals方法和双等号的比较结果应该是一致的（这里没有考虑对象为null的情况，如果调用的对象为null，将引发空指针异常）。

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

那么equals用于比较内容的说法从何而来呢？这是因为很多我们常用的类都重写了equals方法，比如String。换句话说，只有重写了equals方法的类，比较双等号和equals才有意义。

接下来，我们就看一下几种特殊的类中双等号和equals都是如何表现的。

## String类的比较

比较两个字符串的内容是否相等时，应该使用equals方法，因为String类对equals方法进行了重写。

```java
// String的equals方法
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

对于字符串，有时候我们不一定会比较它们的内容，可能会比较两个字符串是否指向同一对象，这时我们就需要使用双等号进行比较。那么使用双等号比较字符串会出现什么样的结果呢？我们来看一些例子：

```java
String a = "abc";
String b = "abc";
String c = new String("abc");
String d = new StringBuilder("abc").toString();
String e = new String("abc").intern();
String f = "ab" + "c";
String g = new String("ab") + new String("c");

System.out.println(a == b); // true
System.out.println(a == c); // false
System.out.println(a == d); // false
System.out.println(a == e); // true
System.out.println(a == f); // true
System.out.println(a == g); // false
```

怎么样小伙伴们，和你们想象的结果一样么？我们来一一分析这些比较结果。

首先是a和b比较的结果为true。有人可能会问，双等号不是比较两个对象是不是同一个对象么？字符串a和b为什么指向同一个对象呢？这里就要引入字符串常量池的概念了。为了提高效率，java在使用字符串的时候并不会每次都生成一个新的字符串，而是在内存中分配一块区域作为常量池，遇到字符串的变量时，优先到常量池中找是否有相同的字符串，如果有的话，直接复用当前的字符串，如果没有的话，再创建新的字符串对象。在上面的例子中，a是字符串"abc"首次出现，因此在常量池中新建了"abc"这一字符串常量(实际上是在编译期创建的)。当变量b再次使用"abc"字符串时，直接复用常量池中的字符串。因此，a和b实际上指向的是同一个对象。

那么a和c的比较结果为什么又是false呢？因为变量c显式地调用了String的构造池，这时字符串将无视常量池中是否有相同的变量，强制重新创建一个字符串，创建的字符串也不会加入常量池中。因此，a和c指向的不是同一个对象。

### 字符串比较结果分析

我们再来看a和d的比较结果。d中使用了StringBuilder，字符串字面量"abc"作为StringBuilder的参数，按理说不会创建新的字符串呀。问题出在后面的toString()方法上，想要把StringBuilder转换为String对象，就需要调用toString()方法。通过查看toString()方法的源码，我们发现在该方法中调用了String的构造器，因此和c一样，重新创建了字符串的对象。

```java
@Override
public String toString() {
    // Create a copy, don't share the array
    return new String(value, 0, count);
}
```

a和e的比较结果比较有意思。e明明调用了String的构造器，为什么比较结果为true呢？关键在于后面的intern()方法，这个方法大家可能不太熟悉，它的作用就是判断常量池中有没有对应的字符串，如果有的话，直接复用该字符串，如果没有的话，创建字符串并加入常量池中。也就是说，调用了intern()方法之后，效果和直接使用字面量是相同的。事实上，按照官方文档的说法，字符串字面量和字符串常量都属于被intern的字符串。调用intern()方法之后，a和e指向了同一个字符串对象。

a与f和g的比较结果我们一起看。先说a和f，变量f创建字符串时，使用了字符串拼接。java在编译过程中，如果发现能够计算的结果，会在编译期直接将结果计算出来。也就是说，编译结束后，f变量也是字符串"abc"这一字面量了。a和f完全相同，根据上述常量池的原理，a和f指向同一对象。再来看g，变量g使用String的构造器进行字符串拼接，由于需要创建对象，在编译期编译器无法对该结果进行求值，因此g只能等待运行期创建两个字符串对象，再进行拼接，二者不会指向同一个对象。

类似地还可以引申出很多种字符串之间进行比较的方式，有兴趣的同学可以自己进行尝试。顺便一提，由于jdk7中将字符串的常量池由方法区移到堆中。使用双等号比较字符串是否指向同一对象时，使用jdk7之前和之后的版本比较结果可能有所不同。

## 包装类的比较

接下来我们来看一下包装类应该使用双等号还是equals进行比较。我们首先尝试像基本类型一样用双等号进行比较。

```java
Integer a = 1;
Integer b = 1;
System.out.println(a == b);
```

输入上述代码，我们的编辑器给我们了一个大大的警告："包装类型间的相等判断应该用equals较，而不是=="。但是我们看一下比较结果呢？控制台输出了一个true。诶？包装类之间也可以用双等号进行比较么？我们把a和b的值都换成129，再次运行程序，控制台输出了一个false。到底发生了什么？原来java的语言规范规定了整数的包装类型Integer类需要对值在-128到127之间的对象进行缓存，缓存在第一次使用该数字时进行初始化。在JVM中，我们还可以通过 -XX:AutoBoxCacheMax=来设置缓存值的范围。同理，其他和整型相关的包装类也存在-128到127之间的缓存，包括Character、Byte、Short、Long。但是这里明确一下，缓存仅仅是为了提高效率的设计，并非为了进行比较。因此，对于包装类，我们应该老老实实的使用equals来比较两个对象包装的值是否相等，否则可能出现意想不到的效果。

## 自定义类的比较

最后我们来看一下自定义类的比较。我们先创建一个简单的类：

```java
class Person {
    public String name;
    public int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

在使用自定义类时，双等号用于比较两个变量是否指向同一对象，而equals用于自定义规则的比较。如果我们想使用equals方法对两个自定义类的对象进行比较，就必须要重写equals方法，大多数情况下应该同时重写hashCode方法。下面还是以Student类为例，先看一下IDE自动生成的equals方法（这里使用了Objects工具类，Objects.equals方法实际上就是封装了对象的equals方法）：

```java
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    Student student = (Student) o;
    return age == student.age &&
            Objects.equals(name, student.name);
}

@Override
public int hashCode() {
    return Objects.hash(name, age);
}
```

可以看出，默认情况下IDE生成的代码是对所有字段分别进行比较，如果全部相等，则两个对象相等。我们可以进行修改，选择其中一部分字段进行比较。

## 总结

总结一下，双等号是二元操作符，可以用于比较基本类型的值是否相等，或者用于比较引用类型的变量是否指向同一对象；equals是Object类中的方法，默认与双等号行为一致，可以通过重写该方法实现自定义规则的比较。常用的类中字符串和包装类应使用equals来比较其内容是否相同。

具体使用建议：

- 对于基本类型，使用双等号进行比较。
- 对于字符串，使用equals进行比较。
- 对于包装类，使用equals进行比较。
- 对于自定义类，双等号用于比较两个变量是否指向同一对象，equals用于自定义规则的比较。

