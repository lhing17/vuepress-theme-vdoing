---
title: Java菜谱（二）——怎么求男学生的平均分？
date: 2021-04-19 14:27:01
permalink: /pages/java-cookbook-two/
description: 通过实际案例详解Java Stream API的使用，对比传统命令式编程与函数式编程的差异，展示Stream在集合操作中的强大威力
categories: 
  - Java
  - Java基础
tags: 
  - Stream
  - 函数式编程
  - 集合操作
author: 
  name: 吉森
  link: https://github.com/lhing17
---

## 问题场景

今天的场景设计是这样的：

给定一批学生分数的数据，求出所有男学生的平均分数。
如果这个命题放在sql中，应该是送分题。在Java中去实现，可能也没有那么难。但是当场景不断复杂化，我们就需要一些技巧来解决这类问题了。

假设Student类的数据结构如下：

```java
@Data
public class Student {
    /**
     * 学生ID
     */
    private String id;
    /**
     * 学生姓名
     */
    private String name;
    /**
     * 学生年龄
     */
    private Integer age;
    /**
     * 学生性别 0-女 1-男
     */
    private Integer gender;
    /**
     * 学生成绩
     */
    private Double score;
}
```

<!-- more -->

## 传统思路

假设学生的数据是以`List<Student>`的形式给出的，让我们先来回顾一下传统思路是怎么解决这个问题的，由于

**平均分数 = 总分 / 人数**

因此，我们需要一个临时变量去记录总分，另一个临时变量去记录男学生的人数，然后我们遍历学生的列表，如果遍历到的学生为男学生，则总分加上当前学生的分数，人数加1，相关代码如下：

```java
Double totalScore = 0.0;
int count = 0;
for (Student student : students) {
    // 男学生
    if (student.getGender() == 1) {
        totalScore += student.getScore();
        count++;
    }
}
Double average = totalScore / count;
System.out.println(average);
```
这样的思路属于命令式编程的范式，即我们一步一步告诉计算机先做什么再做什么，其好处是逻辑简单，容易理解和编写，也容易调试。但是这样的方式编程通常代码量巨大，并且很容易编写出执行效率低下的代码，处理复杂逻辑时更是容易丢掉代码的可读性。

## Stream流式计算

在Jdk8以后，Java引入了lambda表达式，使得Java可以更方便地使用函数式的风格编写程序。而同一版本中Stream的引入更是极大简化了集合的操作。

那么就让我们来看一下在Stream的帮助下如何解决上面的问题：

```java
Double average = students.stream()
                .filter(s -> s.getGender() == 1)
                .collect(Collectors.averagingDouble(Student::getScore));

System.out.println(average);
```
首先通过列表的stream()方法将列表转为流，再通过filter方法对流中的元素进行过滤，最后通过collect方法对流中的元素进行归并，得到最终的结果。事实上，所有使用流的场景都遵循这三个步骤，即流的创建、流的转换以及流的归并。

上述流式计算的方式是一种函数式编程的风格，同时也是属于声明式编程的范式。相比于命令式编程，声明式编程更强调告诉计算机要做什么，而不是具体怎么做。每个步骤具体的实现方案由计算机内部自行实现。当然，这也依赖于Jdk内部提供的强大的api。

## 更复杂的场景

让我们把场景变得更复杂一些，来见识一样流式计算的威力。

### 复杂场景1：学生分属于不同班，计算每个班男同学的平均分

学生的类增加相应字段，改造为：

```java
@Builder
@Data
public class Student {
    /**
     * 学生ID
     */
    private String id;
    /**
     * 学生姓名
     */
    private String name;
    /**
     * 学生年龄
     */
    private Integer age;
    /**
     * 学生性别 0-女 1-男
     */
    private Integer gender;
    /**
     * 学生成绩
     */
    private Double score;
    /**
     * 学生属于哪个班
     */
    private Integer classNumber;
}
```
上述需求实现代码如下：

```java
final Map<Integer, Double> averageMap = students.stream()
                .filter(s -> s.getGender() == 1)
                .collect(Collectors.groupingBy(Student::getClassNumber, 
                    Collectors.averagingDouble(Student::getScore)));
System.out.println(averageMap);
```
由于需要每个班的成绩，我们对学生按班级进行分组，使用的是Collectors工具类提供的groupingBy()方法。这个方法第一个参数是分类的依据，这里传的是Student::getClassNumber这个方法引用，即怎么根据学生对象获取到学生的班级。第二个参数传的是下游的收集器，即分组之后对每组元素做怎样的操作，这里和之前一样传的是对学生的成绩取平均分的操作。如果我们只对数据进行分组，不进行后续处理，第二个参数可以不传（重载方法）。

### 复杂场景2：计算分数高于平均分的学生人数

```java
// 先求平均分
final Double average = students.stream()
    .collect(Collectors.averagingDouble(Student::getScore));

// 再求超过平均分的人数
final long count = students.stream()
    .filter(s -> s.getScore() > average)
    .count();
System.out.println(count);
```
这个需求想整合成一次流式操作比较困难，我们需要先获取班级的平均分，再去计算分数超过平均分的人数。需要注意的是，Stream对象是“一次性的”，当一次归并操作完成后，Stream就会被关闭，这时如果复用之前的对象就会抛出异常。

这里只举这两个例子，Stream还有很多方便的API，感兴趣的可以自行尝试。总结一下，使用Stream可以极大简化集合相关的操作，如果有相关的数据处理需求，可以尝试使用。